### 1. 빅오표기법 규칙
알고리즘의 시간복잡도를 f(n)이라고 표현해보자. n은 입력의 개수를 나타내고, f(n)time은 필요한 시간을 나타내고 f(n)space는 필요한 공간(추가적인 메모리)를 나타낸다. 알고리즘 분석의 목표는 f(n)을 계산함으로써 알고리즘의 효율성을 이해하는 것이다. 
- 계수법칙:
- 합의 법칙
- 곱의 법칙 
- 전이법칙 
- 다항법칙

### 2. 계수법칙
> 2-1. 개념

- 정의: 단순히 입력 크기와 연관되지 않은 상수를 전부 무시하는 것(빅오에서 앞에 붙은 숫자는 전부 무시한다.)
- `빅오는 “데이터가 늘어날 때 증가 속도”만 보기 때문에, 앞에 있는 상수 배수는 의미가 없다.` 라는 가정 때문. 
- 빅오표기법의 법칙 중 가장 중요하다. 
- `상수 k > 0 인 경우 f(n)이 O(g(n)) 이면 kf(n)은 O(g(n))이다.`
- 계수법칙 적용 예시 
	- O(3n) → O(n)
	- O(100n) → O(n)
	- O(0.5n) → O(n)
	- O(7n²) → O(n²)

> 2-2. 예시
- 예시1
```
for i in range(n):
    print(i)
```
→ 연산 횟수: n  
→ 빅오는: **O(n)**

- 예시2 
```
for i in range(3 * n):
    print(i)
```
→ 연산 횟수: 3n  
→ 빅오: **O(n)** ← _앞의 3은 버림. 3배 빠른지 3배 느린지는 큰 그림에서 아무 의미가 없다.  
데이터 크기 n이 커지는 속도에 더 영향을 주는 건 ‘3’이 아니라 ‘n’이기 때문.

- 예시3
```
for i in range(10000 * n):
    do_something()
```
→ 연산 횟수: 10000n  
→ 빅오: **O(n)**

### 3. 합의 법칙 
- 정의: 시간복잡도를 더할 수 있다는 것
```
function a(n){
	var count = 0;
	//A for문
	for(var i=0;i<n;i++){
		count+=1;
	}
	//B for문
	for(var i=0;i<5*n;i++){
		count+=1;
	}
	return count;
}
```
- 시간 복잡도를 계산할 때,A for문 + B for문 하여 계산한다는 법칙. 같은 지수인 것끼리는 실제 더할 수 있다. 

### 4. 곱의 법칙 
```
function a(m){
	var count = 0;
	for (var i=0;i<n;i++){
		count += 1;
		for (var i=0;i<5*n;i++){
			count += 1;
		}
	}
}
return count;
```
- 중첩 for문인 경우 시간복잡도가 서로 곱해진다. 
- 바깥쪽에 있는 for문은 시간복잡도가 O(n),안쪽의 for문은 O(5n)이다. 
- O(n * 5n) = O(5n^2) 이다. 따라서, O(5n^2) 을 빅오표기법으로 계산하면 O(n^2)가 된다. 

### 5. 다항법칙 : '빅오의 K승'
- 정의: f(n)이 k차 다항식이면 f(n)은 O(n^k)
```
function a(n){
	var count = 0;
	for(var i=0;i<n*n;i++){
		count += 1;
	}
	return count;
}
```
- 코드일 때, f(n) = n^2이다. 

