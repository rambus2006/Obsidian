# 1. 연결 리스트 
## { 1-1. 기존 리스트의 문제점 }
- 리스트의 문제점 
	- 자료의 삽입/삭제 연산 과정에서 연속적인 배열을 위해 원소들을 이동시키는 작업이 필요하다. 
	- 원소의 개수가 많고 삽입/삭제 연산이 빈번하게 일어날수록 작업에 소요되는 시간이 크게 증가된다. 
	 - 빅O 연결리스트 
	
## { 1-2. 연결리스트란? }

- 자료의 논리적인 순서와 메모리상의 물리적인 순서가 일치하지 않고, 개별적으로 위치하고 있는 각 원소를 연결하여 하나의 전체적인 자료구조를 이룬다.
- 링크를 통해 원소에 접근하므로, 리스트에서ㅊ럼 물리적인 순서를 맞추기 위한 작업이 필요하지 않다.
- 자료구조의 크기를 동적으로 조정할 수 있어 메모리의 효율적인 사용이 가능하다.
- 연결리스트는 리스트와 다르게 따로 논다. 예를 들어 1번 방에서 2번 방으로 갈 때 1번방에 2번방 주소를 적어둔다. 그럼 중간의 값을 빼도 연결된 주소만 바꾸면 된다. (앞으로 당기지 않아도 된다.)

**<리스트의 구조>**

- 리스트 [ 1,2,3,4,5 ]를 입력하면 실제로는 주소값이 저장되어 있다. [*1000,*2000,*3000,*4000,*5000]
    
    [10000,10032,10064,10096] (32간격: 이 간격을 유지하기 위해 중간에 하나의 값이 빠지면 앞으로 당겨주는 작업을 수행한다.)
    
    - 리스트는 첫 시작점 10000을 가지고 있고 인덱스 [3]을 찾을 때 10000+3*32(BYTE) = 10096 으로 값을 구한 뒤 시작점에서 96BYTE 떨어진 값에 있는 주소를 찾아 주소(이때 이 주소는 메모리이다.) 가 참고하는 값을 반환한다.
    - 어떤 데이터가 있을 때 다음으로 가야 하는 데이터 주소를 LINK 에 저장되어 있어서 실제로 연속되지 않아도 다음 데이터 주소로 이동할 수 있다.

<왜 쓸까? >

- 주소로 데이터 관리를 배우기에 가장 좋은 자료구조
- 참조/메모리 관리를 배우기에 좋음
- 실무에서도 많이 씀

## { 1-2. 연결리스트의 기본 구조 }

- 노드
    - 연결 리스트에서 하나의 원소를 표현하는 기본 구성 요소
    - 구성 요소
        - 데이터 필드
            - 원소의 값을 저장(데이터, 값)
            - 저장할 원소의 종류나 크기에 다라 구조를 정의하여 사용한다.
        - 링크 필드
            - 다음 노드의 참조값을 저장
- 헤드 : 연결 리스트의 첫 노드에 대한 참조값을 갖고 있다.

## { 1-3. 단순 연결 리스트 }

> 단순 연결리스트란?

- 노드가 하나의 링크 필드에 의해 다음 노드와 연결되는 구조를 가진다.
- 헤드가 가장 앞의 노드를 가리키고, 링크 필드가 연속적으로 다음 노드를 가리킨다.
- 링크 필드가 Null 인 노드가 연결 리스트의 가장 마지막 노드이다.
- 리스트가 다 떨어져 있지만 실제 작동 순서는 A→B→C→D